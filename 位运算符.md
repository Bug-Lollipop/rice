#### Not~
Not 实质上是对数字向下取整再求负，再减一

```
var num = 20.1
console.log(~num) // -21
```

#### And &
对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：
第一个数字中的数位	第二个数字中的数位	结果
1	1	1
1	0	0
0	1	0
0	0	0

举例： 30 & 3

我们先来看下两个数的 二进制

```
var i = 30

i.toString(2) // 11110

var j = 3

j.toString(2) // 11

console.log(i & j) // 2

```

为什么是‘2’？

我们来看一下, 按照上表的关系 我们可以得出 下表结果

30	1 1110
3	0 0011
结果	0 0010
二进制 ‘10’ 对应的 十进制数就是 ‘2’了

#### Or |
or跟and 相似 也是 转为二进制之后 进行的 计算 不过规则不同

第一个数字中的数位	第二个数字中的数位	结果
1	1	1
1	0	1
0	1	1
0	0	0
同样的 我们拿 30 | 3来举例

```
var i = 30  
i.toString(2) // 11110  
var j = 3  
j.toString(2) // 11  
console.log(i | j) // 31
```
30	1 1110
3	0 0011
结果	1 1111

#### ^(Xor)

```
var i = 30  
i.toString(2) // 11110  
var j = 3  
j.toString(2) // 11  
console.log(i ^ j) // 29
```


30	1 1110
3	0 0011
结果	1 1101

我们再回到 Not 运算符上，可以说 And Or Xor 这三个位运算 我们用到的可能性比较小
但是 Not 的 法则 是 向下取整 后 求负 减1
注意我 着重标出的 关键字，是不是想到了什么？没错 Math.floor()
如果说 单次 使用 Not 是 求负减1 那么 我连续使用 2次 Not 会怎么样呢？对于 整型 的数字来说 连续两次 就是它本身，那么对于浮点型的数字呢？ 那岂不就是 他的向下取整了么？


```
var i = 25.1  
console.log(~~i) //25
```

但是又有人说 向下取整 不是有 Math.floor() 方法么？

为什么要用 两次 Not 而不用 Math.floor()

第一，你不觉得 ~~ 输入起来 比 Math.floor() 快么？

第二，就是 ~~ 比 Math.floor() 更快。

Math.floor() 运行速度 是 3.5 millions ops/sec

~~ 的运行速度是 3.8 millions ops/sec

但是 ~~ 只适用于 32位 以下的整型，对于 超过32位的 整型 还是要用 Math.floor() 这点要千万注意


