正则表达式在线验证：https://jex.im/regulex/

精确匹配例子：http://rubular.com/

#### 最简单的正则（匹配指定的文本）
将字符串中的【的】匹配出来

```
var str = '前世茫茫人海的擦肩，种了今生的遇见，在花海的某一朵间，是你最美的笑颜。繁花三千，只为一人留恋，几度春秋，只等你花开的一面。多少来来回回，梦里若隐若现，举着思念的酒盏，轻酌夜色微凉，让回忆的美好舞翩翩。搁浅了时光，静默缘分的一端，远处的风景，依然是你微笑的眉眼。'
str.match(/的/g)
```
使用到了match方法来做匹配，

#### test()

test 的返回值是bool 类型，通常用来写在if 语句中判断一个字符串是否满足正则表达式，在表达验证时经常用到

##### 场景一： 账号只能数字
说明，输入非数字不能匹配

了解了规则之后，就很简单了，正则提供了默认匹配数字的字符，d或者是[0-9]，那么是不是直接/d/.test('123')就行了呢？
当然不是，d表示是数字，你还需要加上一个特殊字符，表示匹配所有的数字，因为一个字符串有N个数字，全部都要匹配成功。

这里我使用的是+，加号表示至少匹配一次数字，比如123，如果使用d，就只能一个个匹配出来[1,2,3]，这需要在match方法中使用，
在test方法中，必须匹配整个字符串是否符合正则。改成d+之后，匹配的是整个字符串中的数字，是不是离我们的最终结果很接近了。

上面的操作似乎已经可以匹配出数字了，但是记住，test()方法中，如果你要验证整个字符串只能是数字，必须加上正则的开始符号^和结束符号$，表示的是从字符串'123'开头匹配到结尾都必须满足数字，如果中间插入其他字符'1kk2什么3'，就匹配失败。所以最终的正则写法是 /^\d+$/，或者是/^d+$/g，这里的g可加可不加。
```
var user = '123' //可以把123改成任意字符来测试。
if (/^\d+$/g.test(user)) {} //写法1 if(true){}
if (/^[0-9]+$/g.test(user)) {} //写法2 if(true){}
```
https://segmentfault.com/a/1190000011187831
##### replace()

repalce 和match 比较像，都能匹配出字符，但是repalce 还有第二个参数做字符替换

